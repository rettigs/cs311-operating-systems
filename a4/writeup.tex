\documentclass[letterpaper,10pt,fleqn]{article}

%example of setting the fleqn parameter to the article class -- the below sets the offset from flush left (fl)
\setlength{\mathindent}{1cm}

\usepackage{graphicx}                                        

\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}

\usepackage{pstricks, pst-node}

%the following sets the geometry of the page
\usepackage{geometry}
\geometry{textheight=9in, textwidth=6.5in}

% random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\usepackage{hyperref}

\usepackage{textcomp}
\usepackage{listings}

\usepackage{wasysym}

\def\name{Sean Rettig}

%% The following metadata will show up in the PDF properties
\hypersetup{
  colorlinks = true,
  urlcolor = black,
  pdfauthor = {\name},
  pdfkeywords = {cs311 ``operating systems''},
  pdftitle = {CS 311 Project},
  pdfsubject = {CS 311 Project},
  pdfpagemode = UseNone
}

\parindent = 0.0 in
\parskip = 0.2 in

\pagestyle{empty}

\numberwithin{equation}{section}

\newcommand{\D}{\mathrm{d}}

\newcommand\invisiblesection[1]{%
  \refstepcounter{section}%
  \addcontentsline{toc}{section}{\protect\numberline{\thesection}#1}%
  \sectionmark{#1}}

\begin{document}

%to remove page numbers, set the page style to empty

\section*{Assignment 3 Write-up}
\hrule

\subsection*{Design}
\begin{itemize}
    \item For the trie implementation, I will primarily just be converting the C++ code to C code, which shouldn't require much designing.  I will, however, specialize it to use an int for the ASN rather than keeping it generalized, and make it useable by multiple threads/processes at once by adding locking; a node and its children will be recursively locked for reading and writing while any write is being performed on the node or one of its children.  This will allow reads and writes in other portions of the trie to still be processed during a write.  UPDATE: No locking construct was necessary to allow concurrent access to the trie!  Both adding new nodes and editing nodes are atomic, so the data structure cannot be corrupted by concurrent writes.  At worst, two new nodes will be allocated, but only one will be used; the other one will be overwritten.  This is no worse than if it had simply come after and not been added because it was a duplicate.  Even in the event that a node is read after it is created but before it has finished being updated with the data being written, no errors occur because the reader does not use the node's value unless "populated" is true, and "populated" status is set true only after the node is finished being updated.  At worst, a query that is specified to occur after an entry will return the old value rather than the new value, which could happen anyway, even with locking; one cannot rely on which workers will run first.  For example, an entry worker can read a line and then have a query worker scheduled immediately after it, reading the value before the entry worker even had a chance to lock it.
    \item For the main program, I will simply read the input in line-by-line with scanf(), then either add to the trie or perform a lookup depending on the operation specified.  UPDATE: gets() was used instead of scanf to read in lines; sscanf() was then used to parse the lines where necessary.
    \item To decide which process gets to read from the input next in the multiprocess version, a semaphore will be created and shared between them; all processes constantly check to see if the semaphore is unlocked while they are not currently doing work, and if it is, the process will lock it, read a line of input, and unlock it again.
    \item To decide which thread gets to read from the input next in the multithreaded version, a mutex with a condition variable will be created and shared between them; all threads wait for the mutex to be unlocked while they are not currently doing work, and once it is, the thread will lock it, read a line of input, and unlock it again.  This approach will likely be much faster than the multiprocess version's, because threads waiting for an unlock do not have to constantly check if it is available.  UPDATE: No condition variable was necessary because the workers will simply block on unlocking the stdin mutex.  At this point, I'm not even sure what the purpose of condition variables is.
    \item If a thread/process reads an EOF, it will set an "done" flag that all thread/processes check before attempting to read; if it is set, the thread/process will exit.  This will prevent the other threads/processes from blocking on an empty input, and threads/processes will only terminate once they have finished what they were already working on.
\end{itemize}

\subsection*{Work Log}
\begin{verbatim}
\end{verbatim}

\subsection*{Challenges Overcame}
\begin{itemize}
\end{itemize}

\subsection*{Questions}
\begin{enumerate}
\end{enumerate}

\end{document}
