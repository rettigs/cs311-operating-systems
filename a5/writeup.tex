\documentclass[letterpaper,10pt,fleqn]{article}

%example of setting the fleqn parameter to the article class -- the below sets the offset from flush left (fl)
\setlength{\mathindent}{1cm}

\usepackage{graphicx}                                        

\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}

\usepackage{pstricks, pst-node}

%the following sets the geometry of the page
\usepackage{geometry}
\geometry{textheight=9in, textwidth=6.5in}

% random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\usepackage{hyperref}

\usepackage{textcomp}
\usepackage{listings}

\usepackage{wasysym}

\def\name{Sean Rettig}

%% The following metadata will show up in the PDF properties
\hypersetup{
  colorlinks = true,
  urlcolor = black,
  pdfauthor = {\name},
  pdfkeywords = {cs311 ``operating systems''},
  pdftitle = {CS 311 Project},
  pdfsubject = {CS 311 Project},
  pdfpagemode = UseNone
}

\parindent = 0.0 in
\parskip = 0.2 in

\pagestyle{empty}

\numberwithin{equation}{section}

\newcommand{\D}{\mathrm{d}}

\newcommand\invisiblesection[1]{%
  \refstepcounter{section}%
  \addcontentsline{toc}{section}{\protect\numberline{\thesection}#1}%
  \sectionmark{#1}}

\begin{document}

%to remove page numbers, set the page style to empty

\section*{Assignment 5 Write-up}
\hrule

\subsection*{README}
This README section exists to describe the proper usage of the programs so that they may be tested accordingly.

\subsubsection*{Usage}
This \LaTeX file and ip2asn.c may be compiled by running \texttt{make} with the provided makefile.  ip2asn.py and update.py should be executable with Python 2.6 or 2.7.

Usage information for each program may be viewed by running it with the -h flag, but will also be listed here for convenience:

\begin{verbatim}
Usage: ./ip2asn [-h] [-a ipaddress] [-p port] [-c infile] [-i indb] [-o outdb] [-d]...
    -h  view this help
    -a  specify the IP address to bind to, defaults to INADDR_ANY
    -p  specify the port to bind to, defaults to 54321
    -i  specify an input file to initialize the trie from
    -o  specify an output file to save the trie to upon termination
    -d  enable debug messages; use -dd for more even more messages

Usage: ./ip2asn.py [-h] [-a server_ip] [-p port] [-i infile] [-o outfile] [-q query_ip] [-d]...
    -h  view this help
    -a  specify the IP address of the server to connect to, defaults to 127.0.0.1
    -p  specify the port of the server to connect to, defaults to 54321
    -i  specify an input file of IP addresses to query the server with
    -o  specify an output file for query results, defaults to stdout; only works with -i
    -q  query a single IP address; cannot be used with -i
    -d  enable debug messages; use -dd for more even more messages

Usage: ./update.py [-h] [-a server_ip] [-p port] [-i infile] [-s] [-k] [-d]...
    -h  view this help
    -a  specify the IP address of the server to connect to, defaults to 127.0.0.1
    -p  specify the port of the server to connect to, defaults to 54321
    -i  specify an input file of CIDR prefixes and ASNs to update the server with
    -s  enable reporting mode; query server for usage statistics
    -k  kill the server
    -d  enable debug messages; use -dd for more even more messages
\end{verbatim}

For ip2asn.c and update.py, an infile takes the format of a newline-delimited list of (CIDR prefix, ASN) pairs (as in the provided entries1.txt and entries2.txt files).  This is also the format dumped into the outfile for ip2asn.c.  For ip2asn.py, an infile is a newline-delimited list of IPv4 addresses to query the server with (as in the provided queries.txt file), and an outfile will contain a newline-delimited list of (IP, ASN) pairs.

\subsubsection*{Examples}
A common usage of the ip2asn.c server program:
\begin{verbatim}
    ./ip2asn -i database -o database
\end{verbatim}
This allows the server to maintain its state between runs, as it initializes the trie from its previous dump.

A common usage of the update.c client program:
\begin{verbatim}
    ./update.py -i entries1.txt
    ./update.py -s
    ./update.py -si entries2.txt
    ./update.py -k
\end{verbatim}
The -i, -s, and -k flags may all be specified at once, in which case, the insertions happen first, followed by the statistics query, and finally the kill command.

Common usages of the ip2asn.py client program:
\begin{verbatim}
./ip2asn.py -q 1.2.3.4
./ip2asn.py -i queries.txt
./ip2asn.py -i queries.txt -o outfile
\end{verbatim}
The -q and -i flags may not be used together.

Additionally, all programs may be specified to bind/connect to a specific IP address and port.
\begin{verbatim}
./ip2asn -i database -o database -a 127.0.0.1 -p 33333
./update.py -sp 33333
./ip2asn.py -q 1.2.3.4 -a 128.193.37.168
\end{verbatim}
By default, ip2asn.c binds to INADDR\_ANY, while ip2asn.py and update.py connect to 127.0.0.1.  All three use port 54321 by default.

One may also view debugging messages by specifying the -d flag for any program, or -dd for even more verbose output.  Debug output provides an inside look on how the program is functioning.
\begin{verbatim}
./ip2asn -i database -o database -d
./ip2asn -i database -o database -dd
./update.py -di entries1.txt
\end{verbatim}

\subsection*{Design}
\begin{itemize}
    \item ip2asn.c will use the threaded version of the program from assignment 4 as its base, but rather than creating a predetermined number of workers which all read from stdin, they will be created whenever a new client connects to service that client, and will terminate when the client disconnects.  This worker-thread model is intended to satisfy the extra credit requirement.
    \item ip2asn.c will also be modified to record how many unique hosts have connected, how many queries have been answered, and how many prefixes are stored.  Update: Storing unique hosts was done via a hashtable, specified by uthash.h (http://troydhanson.github.io/uthash/).  This unique-host-tracking model is intended to satisfy the extra credit requirement.
    \item update.py and ip2asn.py will communicate with ip2asn.c via XML, with the commands taking the following forms (sans newlines and indentation):
    \begin{verbatim}
        <entry>
            <cidr> 1.2.3.4/5 </cidr>
            <asn> 6789 </asn>
        </entry>

        <query>
            <ip> 1.2.3.4 </ip>
        </query>

        <answer>
            <asn> 6789 </asn>
        </answer>

        <stats></stats>

        <stats>
            <hosts> 123 </hosts>
            <queries> 456 </queries>
            <prefixes> 789 </prefixes>
        </stats>

        <terminate></terminate>
    \end{verbatim}
    All XML commands will be terminated by newlines, and when a client is done sending commands, it will send a \begin{verbatim}<done></done>\end{verbatim} command.  Update: Since newlines are entered into the string whenever a packet is broken up, this method did not work.  Rather, I implemented basic character counting (on \(\langle\), \(\rangle\), and /) to parse the XML, allowing me to know when one command ended and the next began, ignoring newlines.  Additonally, I was able to simply read an EOF when the client closed the socket, so the ``done'' command was not necessary.
    \begin{itemize}
        \item The entry command is sent from update.py to ip2asn.c to add a new prefix/ASN pair to the trie.
        \item The query command is sent from ip2asn.py to ip2asn.c to get the ASN of the given IP address.
        \item The answer command is sent from ip2asn.c to ip2asb.py to return the ASN of the given IP address.
        \item The empty stats command is sent from update.py to ip2asn.c to query for usage statistics.
        \item The populated stats command is sent from ip2asn.c to update.py to return usage statistics.
        \item The terminate command is sent from update.py to ip2asn.c to terminate ip2asn.c; ip2asn.c will send itself a SIGINT signal via kill(), which causes it to dump the trie to the outfile (if one is specified) and terminate.
    \end{itemize}
\end{itemize}

\subsection*{Work Log}
\begin{verbatim}
\end{verbatim}
\subsection*{Challenges Overcame}
\begin{itemize}
    \item One challenge I overcame involved very confusing behaviour with the XML parser in ip2asn.c; when I simply added a new variable to hold the previous character, the line buffer started getting multiple characters added to it whenever it received only one; after much debugging, I discovered that I had been using strcat with a single char, rather than a string, causing it to add arbitrary data to the line buffer!  This was easily fixed by simply setting the appropriate position in the buffer to the wanted character rather than using strcat.
    \item Another challenge I overcame was mentioned earlier as an update of the design; I was originally delimiting XML commands with newlines, unaware that newlines could be automatically added in arbitrary positions in the string as part of the socket connection.  This required me to add additional logic to parse the XML so I could know whether we had a full command or not, and whether to wait for more characters.
    \item At one point, I realized that the method I had previously been using to dump the trie upon termination did not match what I had to use for input, and that having two different types of input files to specify was silly.  I ended up implementing bin2dec() and binary\_to\_prefix() in addition to dec2bin() and prefix\_to\_binary() to convert the binary prefixes I used to be dumping back into CIDR notation.  However, after implementing it, I noticed that the first line of the output had random, garbled data!  After a bit of debugging, I realized that I needed to zero out the buffer I was using to store the CIDR prefix before using it.
\end{itemize}

\subsection*{Questions}
\begin{enumerate}
    \item The main purpose of this assignment was to learn the usage and semantics of socket creation and I/O, with secondary purposes being to practice Python and parsing strings/XML.  This was also an exercise in problem solving skills, as this system is the most complex one we have written so far and has lots of minor little details to worry about as well as having the main architecture of the system be largely undefined, requiring us to design and implement it on our own.
    \item I ensured my solution was correct by testing each program option under various circumstances, such as when the trie is empty, when the trie already has entries, when new entries are being added, when duplicate entries are being added, when input/output files are specified, when multiple clients are connected, whether batch mode or one-off mode is used for queries, when operations (entries, queries, and stat queries) were interleaved and/or performed in different orders, and when multiple options are specified at once, such as -i, -s, and -k all at the same time on update.py.  The README section describes specifically describes tests that can be performed to ensure the system's correctness.
    \item Obviously, I learned a lot about sockets and Python, given that I had never used sockets before and knew almost no Python; I had to constantly look up even the most basic things about Python, such as how to define functions, how to print, how to format strings, how to catch exceptions, how to check if variables are null/None, how to parse strings using regular expressions, and how to perform file I/O.  Additionally, I learned about parsing my XML commands in a robust enough way to handle being transferred over a network.
\end{enumerate}

\end{document}
