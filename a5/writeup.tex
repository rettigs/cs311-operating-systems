\documentclass[letterpaper,10pt,fleqn]{article}

%example of setting the fleqn parameter to the article class -- the below sets the offset from flush left (fl)
\setlength{\mathindent}{1cm}

\usepackage{graphicx}                                        

\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}

\usepackage{pstricks, pst-node}

%the following sets the geometry of the page
\usepackage{geometry}
\geometry{textheight=9in, textwidth=6.5in}

% random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\usepackage{hyperref}

\usepackage{textcomp}
\usepackage{listings}

\usepackage{wasysym}

\def\name{Sean Rettig}

%% The following metadata will show up in the PDF properties
\hypersetup{
  colorlinks = true,
  urlcolor = black,
  pdfauthor = {\name},
  pdfkeywords = {cs311 ``operating systems''},
  pdftitle = {CS 311 Project},
  pdfsubject = {CS 311 Project},
  pdfpagemode = UseNone
}

\parindent = 0.0 in
\parskip = 0.2 in

\pagestyle{empty}

\numberwithin{equation}{section}

\newcommand{\D}{\mathrm{d}}

\newcommand\invisiblesection[1]{%
  \refstepcounter{section}%
  \addcontentsline{toc}{section}{\protect\numberline{\thesection}#1}%
  \sectionmark{#1}}

\begin{document}

%to remove page numbers, set the page style to empty

\section*{Assignment 5 Write-up}
\hrule

\subsection*{Design}
\begin{itemize}
    \item ip2asn.c will use the threaded version of the program from assignment 4 as its base, but rather than creating a predetermined number of workers which all read from stdin, they will be created whenever a new client connects to service that client, and will terminate when the client disconnects.
    \item ip2asn.c will also be modified to record how many unique hosts have connected, how many queries have been answered, and how many prefixes are stored.  Update: storing unique hosts was done via a hashtable, specified by uthash.h (http://troydhanson.github.io/uthash/).
    \item update.py and ip2asn.py will communicate with ip2asn.c via XML, with the commands taking the following forms (sans newlines and indentation):
    \begin{verbatim}
        <entry>
            <cidr> 1.2.3.4/5 </cidr>
            <asn> 6789 </asn>
        </entry>

        <query>
            <ip> 1.2.3.4 </ip>
        </query>

        <answer>
            <asn> 6789 </asn>
        </answer>

        <stats></stats>

        <stats>
            <hosts> 123 </hosts>
            <queries> 456 </queries>
            <prefixes> 789 </prefixes>
        </stats>

        <terminate></terminate>
    \end{verbatim}
    All XML commands will be terminated by newlines, and when a client is done sending commands, it will send a \begin{verbatim}<done></done>\end{verbatim} command.  Update: Since newlines are entered into the string whenever a packet is broken up, this method did not work.  Rather, I implemented basic character counting (on \(\langle\), \(\rangle\), and /) to parse the XML, allowing me to know when one command ended and the next began, ignoring newlines.  Additonally, I was able to simply read an EOF when the client closed the socket, so the ``done'' command was not necessary.
    \begin{itemize}
        \item The entry command is sent from update.py to ip2asn.c to add a new prefix/ASN pair to the trie.
        \item The query command is sent from ip2asn.py to ip2asn.c to get the ASN of the given IP address.
        \item The answer command is sent from ip2asn.c to ip2asb.py to return the ASN of the given IP address.
        \item The empty stats command is sent from update.py to ip2asn.c to query for usage statistics.
        \item The populated stats command is sent from ip2asn.c to update.py to return usage statistics.
        \item The terminate command is sent from update.py to ip2asn.c to terminate ip2asn.c; ip2asn.c will send itself a SIGINT signal via kill(), which causes it to dump the trie to the outfile (if one is specified) and terminate.
    \end{itemize}
\end{itemize}

\subsection*{Work Log}
\begin{verbatim}
\end{verbatim}
\subsection*{Challenges Overcame}
\begin{itemize}
    \item One challenge I overcame involved very confusing behaviour with the XML parser in ip2asn.c; when I simply added a new variable to hold the previous character, the line buffer started getting multiple characters added to it whenever it received only one; after much debugging, I discovered that I had been using strcat with a single char, rather than a string, causing it to add arbitrary data to the line buffer!  This was easily fixed by simply setting the appropriate position in the buffer to the wanted character rather than using strcat.
    \item Another challenge I overcame was mentioned earlier as an update of the design; I was originally delimiting XML commands with newlines, unaware that newlines could be automatically added in arbitrary positions in the string as part of the socket connection.  This required me to add additional logic to parse the XML so I could know whether we had a full command or not, and whether to wait for more characters.
    \item At one point, I realized that the method I had previously been using to dump the trie upon termination did not match what I had to use for input, and that having two different types of input files to specify was silly.  I ended up implementing bin2dec() and binary\_to\_prefix() in addition to dec2bin() and prefix\_to\_binary() to convert the binary prefixes I used to be dumping back into CIDR notation.  However, after implementing it, I noticed that the first line of the output had random, garbled data!  After a bit of debugging, I realized that I needed to zero out the buffer I was using to store the CIDR prefix before using it.
\end{itemize}

\subsection*{Questions}
\begin{enumerate}
    \item The main purpose of this assignment was to learn the usage and semantics of socket creation and I/O, with secondary purposes being to practice Python and parsing strings/XML.  This was also an exercise in problem solving skills, as this system is the most complex one we have written so far and has lots of minor little details to worry about as well as having the main architecture of the system be largely undefined, requiring us to design and implement it on our own.
    \item I ensured my solution was correct by testing each program option under various circumstances, such as when the trie is empty, when the trie already has entries, when new entries are being added, when duplicate entries are being added, when input/output files are specified, when multiple clients are connected, whether batch mode or one-off mode is used for queries, when operations (entries, queries, and stat queries) were interleaved and/or performed in different orders, and when multiple options are specified at once, such as -i, -s, and -k all at the same time on update.py.  The README section describes specifically describes tests that can be performed to ensure the system's correctness.
    \item Obviously, I learned a lot about sockets and Python, given that I had never used sockets before and knew almost no Python; I had to constantly look up even the most basic things about Python, such as how to define functions, how to print, how to format strings, how to catch exceptions, how to check if variables are null/None, how to parse strings using regular expressions, and how to perform file I/O.  Additionally, I learned about parsing my XML commands in a robust enough way to handle being transferred over a network.
\end{enumerate}

\end{document}
